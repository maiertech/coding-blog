---
title: Authoring libraries
description: An overview of how to author JavaScript libraries.
tags:
  - node
---

https://tooling.js.org/

## Modules

There are two types of modules:

- CommonJS (CJS) modules, the current default, and
- ES modules (ESM), the future default.

## Entry points

- `index.js` in project root is the default entry point.
- `main`
- `browser`
- `module`: this is an inofficial convention entry point for ESM, honored by
  Rollup and Webpack.
- `exports`: this is about encapsualtion

## `package.json`

When `type` is set to `module` this signals that all packages should be
interpreted as ESM. This is the carte blanche approach. If you want to do file
by file you need to work with the `.mjs` extension.

## Why should you use a bundler when authoring libraries?

The primary reason for using a bundler when creating NPM packages is that it can
create entry points for different package formats automatically. You should
support at least CJS and ESM. Additional benefits are:

- A bundler can bundle only what the package actually uses and tree shake
  dependencies.
- For formats that can be loaded from the web, such as UMD, the bundler can
  bundle all dependencies.
- A bundler can optimize CSS or package assets.

But you do not have to use a bundler to create an NPM package. Here are your
options:

### No bundler

This [blog post](https://2ality.com/2019/10/hybrid-npm-packages.html) discusses
options to manually create hybrid NPM packages that support ESM and CJS. If you
do not bundle your package, you need to be aware of all the things ES modules do
not support, e.g. if you require CommonJS modules from an ES module, named
imports do not work. There is a workaround for that, using package
[`esm`](https://www.npmjs.com/package/esm), but it is yet another tool when you
probably tried to omit a bundler and additional tools in the first place.

### Rollup

[Rollup](https://rollupjs.org/guide/en/) is the bundler that introduced tree
shaking. It is able to do static code analysis and include only named imports
into the bundle. Rollup is complicated to use and you should therefore consider
using one of the following options that use Rollup under the hood (zero-config
presets):

- **[Microbundle](https://github.com/developit/microbundle)**: positions itself
  as zero-configuration bundler for tiny modules. But it is not clear what tiny
  means. I started using Microbundle because it was the bundler used to package
  Theme UI. While it works, I am not sure if this is the way to go.
- **[@pika/pack](https://www.pika.dev/blog/introducing-pika-pack):** This is a
  build pipeline for NPM packages. It is mostly about choosing good defaults for
  common tools such as Babel and Rollup to minimize configuration. My
  [note on @pika/pack](/notes/node/pika-pack/) clarifies that it is
  unfortunately not maintained any longer.
- **[TSDX](https://tsdx.io/):** Another zero-config way of buildling NPM
  packages. The constraint is that you have to use TypeScript.

### Webpack

You can also
[use Webpack for authoring libraries](https://webpack.js.org/guides/author-libraries/).
But it comes with the same drawbacks as using Rollup directly instead of using
one of the zero-config presets. Here are the zero-config preset options:

- **[Neutrino](https://neutrinojs.org/):** A zwero-config preset that is based
  on Webpack.

## So what should I use?

Skypack does not have a favorite way of creating NPM packages. Instead, they
work with a
[package qaulity score](https://docs.skypack.dev/package-authors/package-checks)
to guide developers of what to look out for when creating packages. The goal is
to improve package quality without prescribing a specific method to achieve
this.

The only decision to make at this point is whether TSDX can replace Microbundle.
See my [note on TSDX](/notes/node/tsdx/).
