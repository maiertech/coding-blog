---
title: Authoring libraries
description: An overview of how to author JavaScript libraries.
tags:
  - dev
---

## Modules

When writing packages for NPM, you need to understand at least two types of
modules:

- CommonJS modules (current default)
- ES modules (future default)

## Props in `package.json`

| Prop     | Value        | Description                                                                                                                                                                                      |
| :------- | :----------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `main`   | path to file | Entry point for CommonJS and ES modules packages.                                                                                                                                                |
| `module` | path to file | `module` is an inofficial prop in `package.json` that signals that a package is an ES module. It is honored by [Rollup](https://rollupjs.org/guide/en/) and [Webpack](https://webpack.js.org/)). |
| `type`   | `module`     | Signals that this package should be interpreted as ES module. This is the carte blanche approach. If you want to do file by file yuo need to work with the `.mjs` extension.                     |

## Bundlers for NPM packages

If you write your own NPM package, you should support at least CommonJS and ES
modules. Your `package.json` needs to have a `main` entry point for CommonJS and
a `module` entry point for ES modules.

You do not have to use a bundler to create an NPM package, but there are some
benefits:

- A bundler can bundle only what is used and tree shake all dependencies.
- A bundler can create different distributions of your package, eg CJS, ESM and
  UMD.
- For formats that can be loaded from the web, such as UMD, the bundler can
  bundler all dependencies.
- A bundler can optimize CSS or package assets.

These are your tooling options:

### No bundler

This [blog post](https://2ality.com/2019/10/hybrid-npm-packages.html) discusses
options to manually create hybrid NPM packages that support ESM and CJS. If you
do not bundle your package, you need to be aware of all the things ES modules do
not support, eg if you require CommonJS modules from an ES module, named imports
do not work. There is a workaround for that, using package
[`esm`](https://www.npmjs.com/package/esm), but it's another tool when you
probably did not want to use a tool in the first place..

### @pika/pack

[Introducing: @pika/pack](https://www.pika.dev/blog/introducing-pika-pack)

You can think of this package build pipeline as a lightweight bundler.
`@pika/pack` is mostly about choosing good defaults for common tools such as
Babel and Rollup to minimize configuration. It can also help create multiple
distributions.

### Rollup

[Rollup](https://rollupjs.org/guide/en/) is the bundler that introduces tree
shaking. It is able to do static code analysis and include only named imports
into the bundle. It's complicated to use and you should therefore consider using
it in its `@pika/pack` or Microbundle incarnation. Rollup will load an ESM
version of a package when the `module` field is present.

### Webpack

Technically you can use Webpack for
[authoring libraries](https://webpack.js.org/guides/author-libraries/). If you
consider Webpack you should probably choose Rollup instead. While it caught up
with Rollup's features, such as tree shaking, it lacks other features such as
support for different distributions.
